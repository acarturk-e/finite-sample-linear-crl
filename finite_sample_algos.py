"""Sample complexity of interventional causal representation learning -- algorithms.

Minor portions of this file is taken from the algorithms file of
https://github.com/acarturk-e/score-based-crl
with author's permission.
"""

__all__ = ["causal_order_estimation", "graph_estimation", "encoder_estimation"]

import logging

import numpy as np
import numpy.typing as npt


def causal_order_estimation(dsx_cor: npt.NDArray[np.floating]) -> npt.NDArray[np.int_]:
    n, d, _ = dsx_cor.shape
    logging.debug(f"Starting `_causal_order_est`.")

    vt = list(range(n))
    top_order = np.arange(n)

    # When we find a `k` that increases the null space dimension, record and continue
    for t in reversed(range(1, n)):
        logging.debug(f"{t = }, {vt = }")
        min_eigval_l = np.ones(n) * float("+inf")
        for k in vt:
            vt_new = list[int](i for i in vt if i != k)
            min_eigval_l[k] = np.linalg.eigvalsh(np.sum(dsx_cor[vt_new], 0))[d - t - 1]
        youngest_node = np.argmin(min_eigval_l)
        top_order[t] = youngest_node
        vt = list[int](i for i in vt if i != youngest_node)

    # The remaining entry is the oldest
    top_order[0] = vt[0]
    return top_order


def graph_estimation(
    rxs: npt.NDArray[np.floating],
    top_order: npt.NDArray[np.int_],
    atol_eigv: float,
    atol_orth: float
) -> npt.NDArray[np.bool_]:
    n, d, _ = rxs.shape
    logging.debug(f"Starting `_graph_est`.")
    logging.debug(f"{atol_eigv = }, {atol_orth = }")

    # Estimate of the transitive closure
    hat_g_s = np.zeros((n, n), dtype=np.bool_)

    # V_t sets generated by `_causal_order_est`
    vts = [top_order[: t + 1] for t in range(n)]

    for t in reversed(range(n - 1)):
        logging.debug(f"{t = }, {vts[t] = }")

        # Find vt's column space
        cm = np.sum(rxs[vts[t]], 0)
        cm_eig = np.linalg.eigh(cm)
        cm_eigval: npt.NDArray[np.floating] = cm_eig.eigenvalues
        cm_eigvec: npt.NDArray[np.floating] = cm_eig.eigenvectors
        cm_rank = np.sum(cm_eigval > atol_eigv, dtype=np.int_)
        logging.debug(f"Rank of vt column space: {cm_rank}")
        vt_colb = cm_eigvec[:, -(t + 1) :]

        for j in range(t + 1, n):
            mtj = [m for m in vts[j] if m != top_order[t] and not hat_g_s[top_order[t], m]]

            # Find the basis of/orthonormal projector onto the null space of mtj
            if len(mtj) == 0:
                # trivial column space => full null space
                logging.debug(f"{j = }, rank of mtj: 0")
                mtj_nullp = np.eye(d)
            else:
                cm = np.sum(rxs[mtj], 0)
                cm_eig = np.linalg.eigh(cm)
                cm_eigval: npt.NDArray[np.floating] = cm_eig.eigenvalues
                cm_eigvec: npt.NDArray[np.floating] = cm_eig.eigenvectors
                cm_rank = np.sum(cm_eigval > atol_eigv, dtype=np.int_)

                logging.debug(f"{j = }, rank of mtj: {cm_rank}")
                mtj_nullb = cm_eigvec[:, :-cm_rank]
                mtj_nullp = mtj_nullb @ mtj_nullb.T

            # We check for approximate orthogonality between column of vt and null of mtj
            approx_orth_metric = np.linalg.norm(mtj_nullp @ vt_colb, 2)
            if approx_orth_metric <= atol_orth:
                # ... which are orthogonal iff I^{pi_t} in pa_{tc}(I^{pi_j}.
                # Then there is a transitive reduction edge. Add it.
                hat_g_s[top_order[t], top_order[j]] = True
                hat_g_s[top_order[t], :] |= hat_g_s[top_order[j], :]

    return hat_g_s


def encoder_estimation(dsx_cor: npt.NDArray[np.floating], atol_eigv: float) -> npt.NDArray[np.floating]:
    n, d, _ = dsx_cor.shape
    logging.debug(f"Starting `_encoder_est`.")
    logging.debug(f"{atol_eigv = }")

    hat_enc_s = np.zeros((n, d))

    for t in range(n):
        # Find column space of t
        cm_eig = np.linalg.eigh(dsx_cor[t])
        cm_eigval: npt.NDArray[np.floating] = cm_eig.eigenvalues
        cm_eigvec: npt.NDArray[np.floating] = cm_eig.eigenvectors
        cm_rank = np.sum(cm_eigval > atol_eigv, dtype=np.int_)
        logging.debug(f"Rank of t column space: {cm_rank}")
        t_colb = cm_eigvec[:, -(t + 1) :]
        # Heuristic: Use the maximal eigenvector as our estimate.
        hat_enc_s[t, :] = t_colb[:, -1]

    return hat_enc_s
